# Generated by Django 5.2.6 on 2025-10-22 01:45

from django.db import migrations, models


def populate_question_order(apps, schema_editor):
    Question = apps.get_model('concour', 'Question')
    # For each concours, assign incremental order values based on the existing primary key
    # This ensures (concours, order) unique pairs before adding the constraint.
    from collections import defaultdict

    per_concours = defaultdict(list)
    for q in Question.objects.all().order_by('id'):
        per_concours[q.concours_id].append(q.id)

    for concours_id, qids in per_concours.items():
        for idx, qid in enumerate(qids):
            Question.objects.filter(id=qid).update(order=idx)


def noop_reverse(apps, schema_editor):
    # reverse is a noop because removing specific values isn't necessary on rollback
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('concour', '0024_exercicecontext_remove_question_context_text_and_more'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='question',
            options={'ordering': ['order']},
        ),
        # Add the field as nullable first so we can populate values without a default collision
        migrations.AddField(
            model_name='question',
            name='order',
            field=models.PositiveIntegerField(null=True),
        ),
        # Populate order values per concours to ensure uniqueness
        migrations.RunPython(populate_question_order, reverse_code=noop_reverse),
        # Then make the field non-null with a default and add the unique constraint
        migrations.AlterField(
            model_name='question',
            name='order',
            field=models.PositiveIntegerField(default=0),
        ),
        migrations.AddConstraint(
            model_name='question',
            constraint=models.UniqueConstraint(fields=('concours', 'order'), name='unique_order_per_concours'),
        ),
    ]
